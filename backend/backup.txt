from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import JSONResponse
import shutil
import os

import chromadb
from langchain_text_splitters import RecursiveCharacterTextSplitter
from google import genai
from dotenv import load_dotenv
from pypdf import PdfReader
from docx import Document

load_dotenv()
api_key = os.getenv("GEMINI_API_KEY")
if not api_key:
    raise ValueError("GEMINI_API_KEY environment variable not set")

client = genai.Client(api_key=api_key)
chroma_client = chromadb.Client()
collection = chroma_client.get_or_create_collection(name="Pukar_Collection")

app = FastAPI()


# ------------------ Helper functions ------------------

def extract_text_from_file(file_path: str) -> str:
    ext = file_path.lower().split(".")[-1]
    if ext == "pdf":
        reader = PdfReader(file_path)
        text = ""
        for page in reader.pages:
            text += page.extract_text() + "\n"
        return text
    elif ext == "docx":
        doc = Document(file_path)
        return "\n".join([p.text for p in doc.paragraphs])
    elif ext == "txt":
        with open(file_path, "r", encoding="utf-8") as f:
            return f.read()
    else:
        raise ValueError("Unsupported file format, only pdf, docx, and txt allowed.")


def create_chunks_and_store(file_path: str, chunk_size=600, chunk_overlap=100):
    docs = extract_text_from_file(file_path)
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=chunk_size,
        chunk_overlap=chunk_overlap
    )
    chunks = text_splitter.split_text(docs)
    collection.add(
        ids=[f"id{i}" for i in range(len(chunks))],
        documents=chunks
    )
    return len(chunks)


def summarize_text(text: str) -> str:
    prompt = f"""
    Summarize the following document clearly and concisely:
    {text}

    Summary:
    """
    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=prompt
    )
    return response.text.strip()


def rag_query(question: str, k: int = 3) -> str:
    results = collection.query(
        query_texts=[question],
        n_results=k
    )
    retrieved_chunks = results["documents"][0]
    context = "\n".join(retrieved_chunks)
    prompt = f"""
You are an assistant that answers questions using ONLY the provided context.
Do NOT use your own knowledge or make assumptions.
If the answer is not present in the context, respond: "I don't know".

Context:
{context}

Question:
{question}
Answer:
"""
    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=prompt
    )
    return response.text.strip()


def translate_to_nepali(text: str) -> str:
    prompt = f"""
Translate this response in Nepali language:
{text}

Nepali Translation:
"""
    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=prompt
    )
    return response.text.strip()


# ------------------ FastAPI endpoints ------------------

@app.post("/upload/")
async def upload_document(file: UploadFile = File(...)):
    # Save uploaded file temporarily
    file_path = f"temp_{file.filename}"
    with open(file_path, "wb") as f:
        shutil.copyfileobj(file.file, f)

    # Create chunks and store
    num_chunks = create_chunks_and_store(file_path)

    # Extract actual content for summarization if needed
    text = extract_text_from_file(file_path)

    # Delete temp file
    os.remove(file_path)

    return {"message": "File processed", "chunks_created": num_chunks, "text_length": len(text.split())}


@app.post("/summarize/")
async def summarize_document(file: UploadFile = File(...)):
    file_path = f"temp_{file.filename}"
    with open(file_path, "wb") as f:
        shutil.copyfileobj(file.file, f)

    text = extract_text_from_file(file_path)
    summary = summarize_text(text)
    os.remove(file_path)
    return {"summary": summary}


@app.post("/ask/")
async def ask_question(question: str = Form(...), k: int = Form(3)):
    answer = rag_query(question, k)
    return {"answer": answer}


@app.post("/translate/")
async def translate_text(text: str = Form(...)):
    nepali = translate_to_nepali(text)
    return {"nepali_translation": nepali}
